# Copyright (c) Gyorgy Wyatt Muntean 2017
# This file contains functions to generate testbenches for the modules
# produced by the top-level script, generate.py.

from common import *
import os
import random

# Main function for this module, involes the generation of all testbenches
# for the verilog modules generated by the top-level script. 
# This function creates and writes into a directory titled, 'tb'.
def generate( args ):
   # if a module name is supplied, concatenate module names
   mm_tb_name = "sc_matrix_mult_tb"
   dp_tb_name = "sc_dot_product_tb"
   nadder_tb_name = "sc_nadder_tb"
   if args.module_name is not "":
      mm_tb_name += "_" + args.module_name
      dp_tb_name += "_" + args.module_name
      nadder_tb_name += "_" + args.module_name

   # make a folder for the testbenches called 'tb'
   # make a folder call 'data' within 'tb'
   tb = args.dest_dir + "/tb"
   if not os.path.exists( tb ):
      os.makedirs( tb )
   data = tb + "/data"
   if not os.path.exists( data ):
      os.makedirs( data )
 
   # write the matrix multiply testbench
   with open( os.path.join( tb, mm_tb_name + ".v" ), 'w' ) as f:
      #write_mm_tb( f, 
      pass

   # write the dot product testbench
   gen_dp_data( data, args.rep, args.input_size )
   with open( os.path.join( tb, dp_tb_name + ".v" ), 'w' ) as f:
      write_dp_tb( f, args.rep, dp_tb_name, args.input_size )
      pass

   # write the nadder testbench module
   with open( os.path.join( tb, nadder_tb_name + ".v" ), 'w' ) as f:
      write_nadder_tb( f, nadder_tb_name, args.input_size )

# Writes the testbench module for the generated sc_dot_product.
# Parameters:
#  f, the file to write to
#  rep, a string specifying the stochastic representation (either uni or bi)
#  module_name,  a string, the name of the module
#  length, an integer, the length of the input vectors
def write_dp_tb( f, rep, module_name, length ):
    pass

# Writes a testbench module for the generated sc_nadder.
# Parameter:
#  f, the file to write to
#  module_name, the name of the testbench module
#  n, an int, the number of inputs to the nadder
def write_nadder_tb( f, module_name, n ):
   # write the header comment
   write_nadder_tb_header( f )

   # compute number of select streams needed 
   select_width = clogb2( n )

   # compute the max possible number of input stream permutations
   # and select stream permutations
   input_count = int(math.pow( 2, n ))
   select_count = int(math.pow( 2, select_width ))

   write_line( f, "`timescale 1ns / 10ps" )
   write_line( f, "" )
   write_line( f, "module " + module_name + "();" )
   write_line( f, "parameter INPUT_STREAMS = " + str(n) + ";", 1 )
   write_line( f, "parameter SELECT_WIDTH = " + str(select_width) + ";", 1 )
   write_line( f, "" )
   write_line( f, "reg [INPUT_STREAMS-1:0] x;", 1 )
   write_line( f, "reg [SELECT_WIDTH-1:0]  sel;", 1 )
   write_line( f, "wire                    out;", 1 )
   write_line( f, "" )
   write_line( f, "sc_nadder dut(.x(x), .sel(sel), .out(out));", 1 )
   write_line( f, "" )
   write_line( f, "integer errors;", 1 )
   write_line( f, "initial errors = 0;", 1 )
   write_line( f, "" )
   write_line( f, "integer i;", 1 )
   write_line( f, "integer s;", 1 )
   write_line( f, "initial begin", 1 )
   write_line( f, "// initialize inputs", 2 )
   write_line( f, "x = 0;", 2 )
   write_line( f, "sel = 0;", 2 )
   write_line( f, "#25;", 2 )
   write_line( f, "" )
   write_line( f, "// for all input stream permutations, test each possible select permutation", 2 )
   write_line( f, "for(i = 0; i < " + str(input_count) + "; i = i + 1) begin", 2 )
   write_line( f, "x = i;", 3 )
   write_line( f, "for(s = 0; s < " + str(select_count) + "; s = s + 1) begin", 3 )
   write_line( f, "sel = s;", 4 )
   write_line( f, "#5;", 4 )
   write_line( f, "if( x[s] != out ) begin", 4 )
   write_line( f, "$display( \"Error incorrect output. Input streams: %B, Select streams: %B, out: %d\", x, sel, out );", 5 )
   write_line( f, "errors = errors + 1;", 5 )
   write_line( f, "end", 4 )
   write_line( f, "#5;", 4 )
   write_line( f, "end", 3 )
   write_line( f, "end", 2 )
   write_line( f, "" )
   write_line( f, "// error summary", 2 )
   write_line( f, "if( errors > 0 ) begin", 2 )
   write_line( f, "$display(\"Validataion failure: %d error(s).\", errors);", 3 )
   write_line( f, "end else begin", 2 )
   write_line( f, "$display(\"Validation successful.\");", 3 )
   write_line( f, "end", 2 )
   write_line( f, "" )
   write_line( f, "$stop;", 2 )
   write_line( f, "end", 1 )
   write_line( f, "endmodule // sc_nadder_tb" )

   return

# Writes the header comment for nadder testbench to file, f.
def write_nadder_tb_header( f ):
   write_line( f, "//////////////////////////////////////////////////////////////////////////////////" )
   write_line( f, "// Create Date: " + get_time() )
   write_line( f, "//" )
   write_line( f, "// Description: This module serves as a testbench for the sc_nadder module." )
   write_line( f, "// For more information on stochastic computing: https://en.wikipedia.org/wiki/Stochastic_computing" )
   write_line( f, "//////////////////////////////////////////////////////////////////////////////////" )

def gen_dp_data( data_dir, rep, length ):
   DATA_FN = "data_vectors.mif"
   WEIGHT_FN = "weight_vectors.mif"
   SELECT_FN = "select_streams.mif"
   RES_FN = "dp_results.mif"    
   TEST_SIZE = 100

   # compute the bit width of the select streams
   select_width = clogb2( length )

   data_streams = [] # 2D array, this is a list of 100 data streams
   weight_streams = [] # 2D array, list of 100 weight streams
   select_streams = [] # 1D array of select numbers (0->length-1)
   results = [] # a 1D array of results (single bits, 1 or 0)

   # generate data and weights and select stream
   for i in range(0, TEST_SIZE):
      datas = []
      weights = []
      for j in range(0, length):
         # generate bits randomly
         datas.append( random.randint( 0, 1 ) )
         weights.append( random.randint( 0, 1 ) )

      data_streams.append( datas )
      weight_streams.append( weights )
      select_streams.append( random.randint( 0, length - 1 ) )

   # generate the expected outputs
   for i in range(0, TEST_SIZE):
      res = sc_dot_product( data_streams[ i ], weight_streams[ i ], select_streams[ i ] )
      results.append( res )           

   # Open and write data to files 
   with open( os.path.join( data_dir, DATA_FN ), 'w' ) as f:
      for stream in data_streams:
         s_str = stream_to_str( stream )
         f.write( s_str + "\n" )

   with open( os.path.join( data_dir, WEIGHT_FN ), 'w' ) as f:
      for stream in weight_streams:
         s_str = stream_to_str( stream )
         f.write( s_str + "\n" )

   with open( os.path.join( data_dir, SELECT_FN ), 'w' ) as f:
      for stream in select_streams:
         s_str = int_to_n_length_binary( stream, select_width ) 
         f.write( s_str + "\n" )

   with open( os.path.join( data_dir, RES_FN ), 'w' ) as f:
      for result in results:
         res_str = str(result)
         f.write( res_str + "\n" )

   return


#--------Helper functions----------#
# Computes the stochastic dot product of the two vectors, data_vec and weight_vec.
# Parameters:
#  data_vec and weight_vec are arrays of 1's and 0's
#  sel, is an integer in the range of 0 to length-1, where length is size of vectors
def sc_dot_product( data_vec, weight_vec, sel ):
   reverseIndex = len(data_vec) - 1 - sel
   return data_vec[reverseIndex] & weight_vec[reverseIndex]

# Takes in an array of 1's and 0's and outputs a string of
# those 1's and 0's concatenated.
def stream_to_str( stream ):
   s_str = ""
   for bit in stream:
      s_str += str(bit)
        
   return s_str

# Converts a number, num, to a binary string of precision n.
def int_to_n_length_binary( num, n ):
   b_str = bin(num)[2:]
   for i in range(0, n - len(b_str)):
      b_str = "0" + b_str

   return b_str
